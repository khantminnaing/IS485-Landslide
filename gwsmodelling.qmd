---
title: "Landslide Susceptibility Model Development"
author:
  - name: Khant Min Naing
  - name: Ann Mei Yi Victoria Grace
date: 01-07-2024 
date-modified: "last-modified"
categories:
  - R
  - sf
  - gwmodel
output:
  distill::distill_article:
    code_folding: false
    toc: true
    self_contained: false
---

To develop a landslide susceptibility methodology framework, we will explore and calibrate different statistical and machine learning models.

## Import Data

```{r}
pacman::p_load(sf, st, raster, spatstat, tmap, devtools,vtable,ggplot2,egg, corrplot, patchwork, ggstats, ggstatsplot)
```

```{r}
train_grids <- read.csv("~/IS485-Landslide/data/aspatial/train_grid.csv")
```

```{r}
length <- length(train_grids)
length
```

```{r}
names(train_grids)
```

```{r}
train_grids.sf <- st_as_sf(train_grids,
                            coords = c("X", "Y"))
```

## Exploratory Spatial Data Analysis (ESDA)

To calculate the summary statistics of `landslide_train` data frame, we use `st()`.

```{r}
st(train_grids)
```

Next, we will create atrellis plot by using `ggarrange()` of [**ggpubr**](https://cran.r-project.org/web/packages/ggpubr/) package. In this way, we can see the distribution plots of different parameters at the same time.

```{r}
#| fig-width: 10

Elevation <- ggplot(data=train_grids, aes(x= `Elevation`)) + 
  geom_histogram(bins=7, color="black", fill="#e9531e")

Slope_Angle <- ggplot(data=train_grids, aes(x= `Slope_Angle`)) +
  geom_histogram(bins=7, color="black", fill="#e9531e")

Profile_Curvature <- ggplot(data=train_grids, aes(x= `Profile_Curvature`)) + 
  geom_histogram(bins=7, color="black", fill="#DC375E")

Plan_Curvature <- ggplot(data=train_grids, aes(x= `Plan_Curvature`)) +
  geom_histogram(bins=7, color="black", fill="#DC375E")

Proximity_Settlement  <- ggplot(data=train_grids, 
                               aes(x= `Proximity_Settlement`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Proximity_Stream  <- ggplot(data=train_grids, aes(x= `Proximity_Stream`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Proximity_Road <- ggplot(data=train_grids, aes(x= `Proximity_Road`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

Proximity_Fault <- ggplot(data=train_grids, aes(x= `Proximity_Fault`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

Precipitation <- ggplot(data=train_grids, aes(x= `Precipitation`)) +
  geom_histogram(bins=7, color="black", fill="#71508F")

TWI <- ggplot(data=train_grids, aes(x= `TWI`)) +
  geom_histogram(bins=7, color="black", fill="#71508F")

ggarrange(Elevation,Slope_Angle,Profile_Curvature,Plan_Curvature,Proximity_Settlement,Proximity_Stream,Proximity_Road,Proximity_Fault,Precipitation,TWI,
          ncol = 4, nrow = 3)
```

## Inflation Variance Test

## Correlation Matrix

Before building a multinomial logistic regression model, it is important to ensure that the indepdent variables used are **not highly correlated** to each other. If these highly correlated independent variables are used in building a regression model by mistake, the quality of the model will be compromised. This phenomenon is known as **multicollinearity** in statistics.

Correlation matrix is commonly used to visualise the relationships between the independent variables. In this section, the [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package will be used to display the correlation matrix of the independent variables in *condo_resale* data frame.

```{r}
#| fig-width: 10

corrplot(cor(train_grids[, 6:31]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#e4c838","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "number", type = "upper")

corrplot(cor(train_grids[,6:31]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#ffffdd","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "ellipse", type = "upper")
```

### Using ggstats method

```{r}
set.seed(123)

## producing the correlation matrix
ggcorrmat(
  data = train_grids[, 6:31],  
          matrix.type = "upper",
  type = "parametric",
  tr = 0.2,
  tl.cex = 0.1,
  partial = FALSE,
  k = 2L,
  sig.level = 0.05,
  conf.level = 0.95,
  bf.prior = 0.707)
```

## Logistic Regression

```{r}
#| eval: false
set.seed(123)
sample <- sample(c(TRUE, FALSE), nrow(default), replace = T, prob = c(0.6,0.4))
train <- default[sample, ]
test <- default[!sample, ]
```

## Simple Logistic Regression

We will fit a logistic regression model in order to predict the probability of a customer defaulting based on the average balance carried by the customer. The `glm` function fits generalized linear models, a class of models that includes logistic regression. The syntax of the `glm` function is similar to that of `lm`, except that we must pass the argument `family = binomial` in order to tell R to run a logistic regression rather than some other type of generalized linear model.

```{r}
#| eval: false
logit_model <- glm(landslide ~ ., family = "binomial", data = landslide_train)
```

## Emerging Hot Spot Analysis

```{r}
#| eval: false
pacman::p_load(sd,tmap,spdep,spData)
coords <- cbind(longitude, latitude)
```

The function `knearneigh` returns a matrix with the indices of points belonging to the set of the k nearest neighbours of each other.

The function `knn2nb` converts a `knn` object returned by `knearneigh` into a neighbours list of class `nb` with a list of integer vectors containing neighbour region number ids.

The function `nbdists` returns the Euclidean distances along the spatial neighbour links in a list.

```{r}
#| eval: false
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

#### Computing fixed distance weight matrix

```{r}
#| eval: false
weight_matrix <- dnearneigh(coords, 0, 106, longlat = TRUE)
weight_matrix
```

## Spatial Neighbourhood

Create Neighbourhood Matrix using Queen

```{r}
#| eval: false
nb <- spdep::poly2nb(landslide_train, queen = TRUE)
head(nb)
plot(st_geometry(landslide_train), border = "lightgray")
plot.nb(nb, st_geometry(landslide_train), add = TRUE)
```

Create a demo visual of how spatial neighbourhood works

```{r}
#| eval: false
id <- 20 # custom area id 
landslide_train$neighbors <- "other"
landslide_train$neighbors[id] <- "point of interest"
landslide_train$neighbors[nb[[id]]] <- "neighbours"
ggplot(landslide_train) + geom_sf(aes(fill = neighbors)) + theme_bw() +
  scale_fill_manual(values = c("gray30", "gray", "white"))
```

The function `nb2listw()` of the spdep package can be used to construct a spatial neighborhood matrix containing the spatial weights corresponding to a neighbors list. The neighbors can be binary or based on inverse distance values.

```{r}
#| eval: false
spatial_w_matrix <- listw2mat(nbw)
```

We can visualize the spatial weight matrix by creating a matrix with the weights with `listw2mat()`, and using `lattice::levelplot()` to create the plot

```{r}
#| eval: false
lattice::levelplot(t(m1),
    scales = list(y = list(at = c(10, 20, 30, 40),
    labels = c(10, 20, 30, 40))))
```

## 
