---
title: "Landslide Susceptibility Model Development"
author:
  - name: Khant Min Naing
  - name: Ann Mei Yi Victoria Grace
date: 01-07-2024 
date-modified: "last-modified"
categories:
  - R
  - sf
  - gwmodel
output:
  distill::distill_article:
    code_folding: false
    toc: true
    self_contained: false
---

To develop a landslide susceptibility methodology framework, we will explore and calibrate different statistical and machine learning models.

## 1.0 Import Packages

-   `car` : Companion to Applied Regression

```{r}
pacman::p_load(sf, st, spdep, raster, spatstat, tmap, devtools,vtable,ggplot2,egg, corrplot, patchwork, ggstats, ggstatsplot, GWmodel, tidyverse, gtsummary,vtable, sjPlot, sjmisc, sjlabelled, tableHTML, olsrr, car)
```

## 2.0 Import Data

```{r}
train_grids <- read.csv("~/IS485-Landslide/data/aspatial/train_grid.csv")
train_grids_v2 <- read.csv("~/IS485-Landslide/data/aspatial/train_grid_v2.csv")
```

```{r}
length <- length(train_grids)
length
```

```{r}
train_grids.sf <- st_as_sf(train_grids,
                            coords = c("X", "Y"))
train_grid_v2.sf <- st_as_sf(train_grids_v2,
                            coords = c("X", "Y"))
```

## 3.0 Exploratory Spatial Data Analysis (ESDA) - V1

To calculate the summary statistics of `landslide_train` data frame, we use `st()`.

```{r}
st(train_grids)
```

Next, we will create atrellis plot by using `ggarrange()` of [**ggpubr**](https://cran.r-project.org/web/packages/ggpubr/) package. In this way, we can see the distribution plots of different parameters at the same time.

```{r}
#| fig-width: 10

Elevation <- ggplot(data=train_grids, aes(x= `Elevation`)) + 
  geom_histogram(bins=7, color="black", fill="#e9531e")

Slope_Angle <- ggplot(data=train_grids, aes(x= `Slope_Angle`)) +
  geom_histogram(bins=7, color="black", fill="#e9531e")

Profile_Curvature <- ggplot(data=train_grids, aes(x= `Profile_Curvature`)) + 
  geom_histogram(bins=7, color="black", fill="#DC375E")

Plan_Curvature <- ggplot(data=train_grids, aes(x= `Plan_Curvature`)) +
  geom_histogram(bins=7, color="black", fill="#DC375E")

Proximity_Settlement  <- ggplot(data=train_grids, 
                               aes(x= `Proximity_Settlement`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Proximity_Stream  <- ggplot(data=train_grids, aes(x= `Proximity_Stream`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Proximity_Road <- ggplot(data=train_grids, aes(x= `Proximity_Road`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

Proximity_Fault <- ggplot(data=train_grids, aes(x= `Proximity_Fault`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

Precipitation <- ggplot(data=train_grids, aes(x= `Precipitation`)) +
  geom_histogram(bins=7, color="black", fill="#71508F")

TWI <- ggplot(data=train_grids, aes(x= `TWI`)) +
  geom_histogram(bins=7, color="black", fill="#71508F")

ggarrange(Elevation,Slope_Angle,Profile_Curvature,Plan_Curvature,Proximity_Settlement,Proximity_Stream,Proximity_Road,Proximity_Fault,Precipitation,TWI,
          ncol = 4, nrow = 3)
```

### 3.1 Correlation Matrix Using Corrplot

Before building a logistic regression model, it is important to ensure that the indepdent variables used are **not highly correlated** to each other. If these highly correlated independent variables are used in building a regression model by mistake, the quality of the model will be compromised. This phenomenon is known as **multicollinearity** in statistics.

Correlation matrix is commonly used to visualise the relationships between the independent variables. In this section, the [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package will be used to display the correlation matrix of the independent variables in *condo_resale* data frame.

```{r}
#| fig-width: 10

corrplot(cor(train_grids[, 6:31]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#e4c838","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "number", type = "upper")

corrplot(cor(train_grids[,6:31]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#ffffdd","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "ellipse", type = "upper")
```

Matrix reorder is very important for mining the hiden structure and patter in the matrix. There are four methods in corrplot (parameter order), named "AOE", "FPC", "hclust", "alphabet". In the code chunk above, AOE order is used. It orders the variables by using the *angular order of the eigenvectors* method suggested by [Michael Friendly](https://www.datavis.ca/papers/corrgram.pdf).

### 3.2 Correlation Matrix tUsing ggstats

```{r}
#| fig-width: 10

set.seed(123)
## producing the correlation matrix
ggcorrmat(
  data = train_grids[, 6:31],  
          matrix.type = "upper",
  type = "parametric",
  tr = 0.2,
  partial = FALSE,
  k = 2L,
  sig.level = 0.05,
  conf.level = 0.95,
  bf.prior = 0.707,
  ggcorrplot.args = list(
     tl.cex = 10,
     pch.cex = 5,
     lab_size = 3
  )) + ## modification outside `{ggstatsplot}` using `{ggplot2}` functions
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(
      margin = ggplot2::margin(t = 0.15, r = 0.15, b = 0.15, l = 0.15, unit = "cm")
    )
  )
```

### 3.3 Test for Spatial Autocorrelation

First, we will import the dataset.

```{r}
train_point <- read_sf(dsn = "./data/vector", layer = "train_point") %>% st_transform(crs = 32632)

train_point
```

In order to perform spatial autocorrelation test, we need to convert *train_point* from sf data frame into a **SpatialPointsDataFrame**.

```{r}
train_point.sp <- as_Spatial(train_point)

```

### 3.4 Simple Logistic Regression

We will fit a logistic regression model in order to predict the probability of a customer defaulting based on the average balance carried by the customer. The `glm` function fits generalized linear models, a class of models that includes logistic regression. The syntax of the `glm` function is similar to that of `lm`, except that we must pass the argument `family = binomial` in order to tell R to run a logistic regression rather than some other type of generalized linear model.

```{r}
landslide.lr <- glm(Landslide ~ Elevation + Slope_Angle + Aspect_North + Aspect_NorthEast + Aspect_East+Aspect_SouthEast+Aspect_South + Aspect_SouthWest +Aspect_West + Aspect_NorthWest + Profile_Curvature +Plan_Curvature + Lithology_Metamorphic+Lithology_Sedimentary + Lithology_Volcanic+Lithology_Plutonic+Lithology_Unconsolidated + Proximity_Settlement+Proximity_Stream+Proximity_Road+Proximity_Fault+Landuse_Nonvegetation+Landuse_Vegetation+Precipitation+TWI, family = "binomial", data = train_grids)
```

```{r}
summary(landslide.lr)
```

```{r}
anova(landslide.lr)
```

```{r warning=FALSE}
tbl_regression(landslide.lr, intercept = TRUE)
```

We can use the **`confint`** function to obtain confidence intervals for the coefficient estimates. Note that for logistic models, confidence intervals are based on the profiled log-likelihood function. We can also get CIs based on just the standard errors by using the default method.

### 3.5 Confidence Intervals Using Profiled Lag-Likelihood

```{r}
confint(landslide.lr)
```

### 3.6 Confidence Intervals Using Standard Errors

```{r}
confint.default(landslide.lr)
```

```{r}
vif(landslide.lr)
vif_values <- vif(landslide.lr)
```

```{r}
vif_values
```

## 

## 4.0 Exploratory Spatial Data Analysis (ESDA) - V2

To calculate the summary statistics of `landslide_train` data frame, we use `st()`.

```{r}
st(train_grids_v2)
```

Next, we will create atrellis plot by using `ggarrange()` of [**ggpubr**](https://cran.r-project.org/web/packages/ggpubr/) package. In this way, we can see the distribution plots of different parameters at the same time.

```{r}
#| fig-width: 10

Elevation <- ggplot(data=train_grids_v2, aes(x= `Elevation`)) + 
  geom_histogram(bins=7, color="black", fill="#e9531e")

Slope_Angle <- ggplot(data=train_grids_v2, aes(x= `Slope_Angle`)) +
  geom_histogram(bins=7, color="black", fill="#e9531e")

Profile_Curvature <- ggplot(data=train_grids_v2, aes(x= `Profile_Curvature`)) + 
  geom_histogram(bins=7, color="black", fill="#e9531e")

Plan_Curvature <- ggplot(data=train_grids_v2, aes(x= `Plan_Curvature`)) +
  geom_histogram(bins=7, color="black", fill="#DC375E")

Proximity_Settlement  <- ggplot(data=train_grids_v2, 
                               aes(x= `Proximity_Settlement`)) +
  geom_histogram(bins=7, color="black", fill="#DC375E")

Proximity_Stream  <- ggplot(data=train_grids, aes(x= `Proximity_Stream`)) +
  geom_histogram(bins=7, color="black", fill="#DC375E")

Proximity_Road <- ggplot(data=train_grids_v2, aes(x= `Proximity_Road`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Proximity_Fault <- ggplot(data=train_grids_v2, aes(x= `Proximity_Fault`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

Precipitation <- ggplot(data=train_grids_v2, aes(x= `Precipitation`)) +
  geom_histogram(bins=7, color="black", fill="#c4102c")

TWI <- ggplot(data=train_grids_v2, aes(x= `TWI`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

SPI <- ggplot(data=train_grids_v2, aes(x= `SPI`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

STI <- ggplot(data=train_grids_v2, aes(x= `STI`)) +
  geom_histogram(bins=7, color="black", fill="#AE4285")

ggarrange(Elevation,Slope_Angle,Profile_Curvature,Plan_Curvature,Proximity_Settlement,Proximity_Stream,Proximity_Road,Proximity_Fault,Precipitation,TWI,SPI,STI,
          ncol = 4, nrow = 4)
```

### 4.1 Correlation Matrix Using Corrplot

Before building a logistic regression model, it is important to ensure that the indepdent variables used are **not highly correlated** to each other. If these highly correlated independent variables are used in building a regression model by mistake, the quality of the model will be compromised. This phenomenon is known as **multicollinearity** in statistics.

Correlation matrix is commonly used to visualise the relationships between the independent variables. In this section, the [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package will be used to display the correlation matrix of the independent variables in *condo_resale* data frame.

```{r}
#| fig-width: 10

corrplot(cor(train_grids_v2[, 6:33]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#e4c838","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "number", type = "upper")

corrplot(cor(train_grids_v2[,6:33]), diag = FALSE, order = "AOE",
         col=colorRampPalette(c("#50a8b4","#ffffdd","#be804f"))(10),
         tl.pos = "td", tl.cex = 0.5,tl.col = "black", number.cex = 0.5, method = "ellipse", type = "upper")
```

Matrix reorder is very important for mining the hiden structure and patter in the matrix. There are four methods in corrplot (parameter order), named "AOE", "FPC", "hclust", "alphabet". In the code chunk above, AOE order is used. It orders the variables by using the *angular order of the eigenvectors* method suggested by [Michael Friendly](https://www.datavis.ca/papers/corrgram.pdf).

### 4.2 Correlation Matrix Using ggstats

```{r}
#| fig-width: 10

set.seed(123)
## producing the correlation matrix
ggcorrmat(
  data = train_grids_v2[, 6:33],  
          matrix.type = "upper",
  type = "parametric",
  tr = 0.2,
  partial = FALSE,
  k = 2L,
  sig.level = 0.05,
  conf.level = 0.95,
  bf.prior = 0.707,
  ggcorrplot.args = list(
     tl.cex = 10,
     pch.cex = 5,
     lab_size = 3
  )) + ## modification outside `{ggstatsplot}` using `{ggplot2}` functions
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(
      margin = ggplot2::margin(t = 0.15, r = 0.15, b = 0.15, l = 0.15, unit = "cm")
    )
  )
```

### 4.3 Simple Logistic Regression

We will fit a logistic regression model in order to predict the probability of a customer defaulting based on the average balance carried by the customer. The `glm` function fits generalized linear models, a class of models that includes logistic regression. The syntax of the `glm` function is similar to that of `lm`, except that we must pass the argument `family = binomial` in order to tell R to run a logistic regression rather than some other type of generalized linear model.

```{r}
landslide.lr_2 <- glm(Landslide ~ Elevation + Slope_Angle + Aspect_North + Aspect_NorthEast + Aspect_East+Aspect_SouthEast+Aspect_South + Aspect_SouthWest +Aspect_West + Aspect_NorthWest + Profile_Curvature +Plan_Curvature + Lithology_Metamorphic+Lithology_Sedimentary + Lithology_Volcanic+Lithology_Plutonic+Lithology_Unconsolidated + Proximity_Settlement+Proximity_Stream+Proximity_Road+Proximity_Fault+Landuse_Nonvegetation+Landuse_Vegetation+Precipitation+TWI+SPI+STI, family = "binomial", data = train_grids_v2)
```

```{r}
summary(landslide.lr_2)
```

```{r}
anova(landslide.lr_2)
```

```{r warning=FALSE}
tbl_regression(landslide.lr_2, intercept = TRUE)
```

We can use the **`confint`** function to obtain confidence intervals for the coefficient estimates. Note that for logistic models, confidence intervals are based on the profiled log-likelihood function. We can also get CIs based on just the standard errors by using the default method.

### 4.4 Confidence Intervals Using Profiled Lag-Likelihood

```{r}
confint(landslide.lr_2)
```

### 4.5 Confidence Intervals Using Standard Errors

```{r}
confint.default(landslide.lr_2)
```

```{r}
vif_values <- vif(landslide.lr_2)
vif_values
```

## 
